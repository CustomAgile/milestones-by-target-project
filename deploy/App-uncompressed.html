<!DOCTYPE html>
<html>
<head>
    <title>Milestones by Project</title>
    <!--  (c) 2020 Custom Agile.  All Rights Reserved. -->
    <!--  Build Date: Thu Oct 22 2020 12:12:30 GMT-0400 (Eastern Daylight Time) -->
    <!--  Version: "0.1.1"-->
    <!--  Repository: "https:/github.com/CustomAgile/milestones-by-target-project"-->
    <script type="text/javascript" src="/apps/2.0/sdk-debug.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                Ext.define('CustomAgile.ui.picker.MultiSelectTimebox', {
    extend: 'Rally.ui.picker.MultiObjectPicker',
    alias: 'widget.customagilemultiselecttimebox',

    config: {
        remoteFilter: true,
        maxLength: 100,
        projects: null,
        pickerCfg: {
            cls: 'multiselect-timebox-picker',
            minWidth: 350
        },
        width: 150,
        enableGrouping: false,
        toggleOnClick: true,
        timeboxStartDateField: '',
        timeboxEndDateField: ''
    },

    initComponent() {
        Rally.ui.list.PagingToolbar.prototype.emptyMsg = 'No timeboxes';

        this.callParent(arguments);

        if (!this.store) {
            this.createStore();
        }
    },

    triggerBlur() {
        const { picker } = this;

        if (picker && picker.isVisible()) {
            this.collapse();
            this.callParent(arguments);
        }
    },

    getMatchedTextHtml(recordData) {
        return `<div class="timebox-name">${recordData.Name}</div>`;
    },

    resetFilters() {
        // TODO: do we need this for remote filter?
        // this.store.setFilter(this.getBaseFilter());
    },

    setValueBasedOnState(values = []) {
        const items = Ext.isString(values) ? values.split(',') : Ext.Array.from(values);

        if (!_.isEmpty(items) && this.store && this.store.isLoading()) {
            this.store.on('load', () => {
                this._selectValues(items);
            }, this, { single: true });
        } else {
            this._selectValues(items);
        }

        if (this.isExpanded) {
            this._onListRefresh();
            this._groupSelectedRecords();
        }

        this.fireEvent('stateapplied', this, this.selectedValues.getRange(), null);
    },

    setDefaultValue(items) {
        this._selectValues(items);

        this.fireEvent('defaultapplied', this, this.selectedValues.getRange(), null);
    },

    // eslint-disable-next-line consistent-return
    getTimeboxOidsInScope(selectedTimeboxes, callbackFn, scope) {
        if (selectedTimeboxes.length > 0) {
            let config = {
                model: Ext.identityFn(this.modelType),
                filters: this._getTimeboxFilters(selectedTimeboxes),
                fetch: ['Name', this.timeboxStartDateField, this.timeboxEndDateField, 'ObjectID'],
                autoLoad: true,
                listeners: {
                    load: (store, sharedTimeboxesInScope) => {
                        Ext.callback(callbackFn, scope, [sharedTimeboxesInScope]);
                    }
                }
            };
            if (this.projects) {
                config.filters = config.filters.and({ property: 'Project.ObjectID', operator: 'in', value: this.projects });
                config.context = {
                    project: null
                };
            }
            Ext.create('Rally.data.wsapi.Store', config);
        } else {
            Ext.callback(callbackFn, scope, [[]]);
        }
    },

    _getTimeboxFilters(records) {
        let filters = [];
        let foundSharedSchedule = {};

        _.each(records, (record) => {
            let key = `${record.get('Name')}-${record.get(this.timeboxStartDateField)}-${record.get(this.timeboxEndDateField)}`;
            if (!foundSharedSchedule[key]) {
                foundSharedSchedule[key] = true;
                let filterByTimebox = Rally.data.wsapi.Filter.and([
                    {
                        property: 'Name',
                        value: record.get('Name')
                    },
                    {
                        property: this.timeboxStartDateField,
                        value: record.get(this.timeboxStartDateField)
                    },
                    {
                        property: this.timeboxEndDateField,
                        value: record.get(this.timeboxEndDateField)
                    }
                ]);
                filters.push(filterByTimebox);
            }
        });
        return Rally.data.wsapi.Filter.or(filters);
    },

    /**
     * @override
     * Add support for specifying a store config option
     */
    createStore() {
        if (!this.store) {
            let storeBuilder = Ext.create('Rally.data.DataStoreBuilder');
            let storeConfig = Ext.merge({ model: this.modelType, requester: this }, this.storeConfig);

            return storeBuilder.build(storeConfig).then({
                success(store) {
                    this.store = store;
                    this.relayEvents(this.store, ['datachanged']);
                },
                scope: this
            });
        }
        return Promise.resolve(this.store);
    },

    /**
    * @override
    * Set buffer on keyup event for remote filtering to work
    * Add listener to inputtextchanged for local filtering
    */
    _initInputEvents() {
        if (!this.rendered) {
            this.on('afterrender', this._initInputEvents, this, { single: true });
            return;
        }

        this.on('expand', this.refreshView, this);
        // this.on('inputtextchanged', this._onInputTextChanged, this);
        this.mon(this.inputEl, 'keydown', this._onInputKeyDown, this, { buffer: 700 });
        this.mon(this.inputEl, 'keyup', this.validate, this, { buffer: 700 });
        this.mon(this.inputEl, 'keyup', this._onInputKeyUp, this, { buffer: 700 });
    },

    _onInputTextChanged() {
        this.store.clearFilter();
        this.store.filter({
            anyMatch: true, exactMatch: false, property: 'Name', value: this.getInputTextValue()
        });
        this.store.load();
    },

    /**
     * @override
     * Filter store if search field cleared
     */
    _onInputKeyUp(event) {
        this._setAppropriateEmptyText();

        // allow shift but disregard other modifiers
        if (event.shiftKey || !Rally.util.Event.isModifierKey(event)) {
            this._onInputTextChanged();
            // this.fireEvent('inputtextchanged', this.getInputTextValue());
        }
        if (this.getInputTextValue() === '') {
            if (this.store.filters) {
                this.store.filters.clear();
            }
            this.store.load();
        }
    },

    /**
    * @override
    * Wire up listeners for select and deselect instead of itemclick
    */
    _createList() {
        this.listCfg.pageSize = 10;
        let listCfg = Ext.apply({
            store: this.store,
            tpl: this._getListTpl(),
            createPagingToolbar: Ext.bind(this._createPagingToolbar, this)
        }, this.listCfg);

        this.list = Ext.create(this.listType, listCfg);

        this.mon(this.list, {
            refresh: this._onListRefresh,
            select: this.onListItemSelect,
            deselect: this.onListItemDeselect,
            scope: this
        });

        const pagingToolbar = this.getList().down('rallylistpagingtoolbar');
        pagingToolbar.onLoad();

        return this.list;
    },

    /**
     * @override
     * New signaure for onListItemSelect since wired up to select on the list
     */
    onListItemSelect(list, record) {
        this.select(record);
        this._selectRowCheckbox(record.get(this.recordKey));
        this._groupRecordsAndScroll(this._getRecordValue());
        this.refreshView();
        this.fireEvent('select', this, record, this.getValue());
        this._fireSelectionChange();
    },

    /**
     * @override
     * Find record in selectedValues mixedcollection and remove the record to be removed
     * New signaure for onListItemDeselect since wired up to deselect on the list
     */
    onListItemDeselect(list, record) {
        let foundRecord = null;

        const key = this._getKey(record);
        this.selectedValues.each((r) => {
            if (r.get('_ref') === key) {
                foundRecord = r;
            }
        });
        if (foundRecord) {
            this.selectedValues.remove(foundRecord);
        }
        this._syncSelection();
        this._deselectRowCheckbox(record.get(this.recordKey));
        this._groupRecordsAndScroll(this._getRecordValue());
        this.fireEvent('deselect', this, record, this.getValue());
        this._fireSelectionChange();
    },

    /**
    * @override
    * Fix for bug where sometimes the itemEl is not there
    */
    _deselectRowCheckbox(recordId) {
        if (this._getOptionCheckbox(recordId)) {
            this._getOptionCheckbox(recordId).removeCls('rui-picker-cb-checked');
        }
    },

    /**
    * @override
    */
    _onStoreLoaded() {
        this._syncSelection();

        this.callParent(arguments);
    },

    _createPagingToolbar() {
        return Ext.widget('rallylistpagingtoolbar', {
            store: this.store,
            border: false,
            layout: {
                align: 'middle'
            }
        });
    }
});
                Ext.define('CustomAgile.ui.picker.MultiSelectProject', {
    extend: 'CustomAgile.ui.picker.MultiSelectTimebox',
    alias: 'widget.customagilemultiselectproject',
    requires: [
        'CustomAgile.ui.picker.MultiSelectTimebox'
    ],

    config: {
        modelType: 'Project',
        emptyText: 'Search projects...',
        storeConfig: {
            autoLoad: true,
            limit: 10,
            pageSize: 10,
            remoteSort: true,
            remoteFilter: true,
            fetch: ['ObjectID', 'Name'],
            sorters: [{ property: 'Name', direction: 'ASC' }],
            context: { project: null }
        }
    },

    /**
     * @override
     * override no data message
     */
    initComponent() {
        this.callParent(arguments);

        Rally.ui.list.PagingToolbar.prototype.emptyMsg = `No ${this.modelType}s`;
    },

    getFilter() {
        let projects = this.getValue();

        return {
            property: 'Project',
            operator: 'in',
            value: _.map(projects, p => p.get('_ref'))
        };
    },

    getLookbackFilter() {
        let projects = this.getValue();

        return {
            property: 'Project',
            operator: 'in',
            value: _.map(projects, p => p.get('ObjectID'))
        };
    }
});

                Ext.define('Customagile.ui.PillPicker', {
    extend: 'Ext.Container',
    alias: 'widget.customagilepillpicker',

    /**
     * @cfg {Object} config for the MultiObjectPicker
     */
    pickerCfg: null,

    /**
     * @cfg {Boolean} true to show pills
     */
    showPills: true,

    /**
    * @cfg {String} Unique string to persist selected items
    */
    statefulKey: null,

    /**
     * @cfg {Boolean} true if omitting same timebox name/dates
     */
    sharedSchedules: false,

    /**
   * @cfg {Boolean} true to set picker to most recent 5 timeboxes if no selections restored from state
   */
    defaultToRecentTimeboxes: true,

    initComponent() {
        let selectedItems = [];
        this.recordsToAdd = [];

        this.picker = Ext.ComponentManager.create(this.pickerCfg);
        this.mon(this.picker, 'selectionchange', this._onSelectionChange, this);
        this.mon(this.picker, 'select', this._onItemSelect, this);
        this.mon(this.picker, 'deselect', this._onItemDeselect, this);
        this.mon(this.picker, 'expand', this._onInitialExpand, this, { single: true });

        this.items = this._createItems();

        if (this.statefulKey) {
            selectedItems = JSON.parse(localStorage.getItem(this.statefulKey));
        }

        if (selectedItems && selectedItems.length > 0) {
            Ext.create('Rally.data.wsapi.RefsToRecords').convert(selectedItems, { requester: this }).then({
                success: (timeboxes) => {
                    if (this.sharedSchedules) {
                        this.picker.getTimeboxOidsInScope(timeboxes, (recordsToAdd) => {
                            this.recordsToAdd = recordsToAdd;
                            if (recordsToAdd && recordsToAdd.length > 0) {
                                this.picker.setValueBasedOnState(recordsToAdd);
                                this._addPills(recordsToAdd);
                                this.saveStateLocal(recordsToAdd);
                            } else {
                                this._setDefaults();
                            }
                        }, this);
                    } else {
                        this.recordsToAdd = timeboxes;
                        this.picker.setValueBasedOnState(timeboxes);
                        this._addPills(timeboxes);
                        this.saveStateLocal(timeboxes);
                    }
                },
                scope: this
            });
        } else {
            if (this.sharedSchedules) {
                const records = this.picker.store.getRange(0, 9);
                if (this.defaultToRecentTimeboxes) {
                    this.recordsToAdd = records;
                    this.picker.setDefaultValue(records);
                } else {
                    this.recordsToAdd = [];
                    this.picker.setValueBasedOnState([]);
                }
            } else {
                this.picker.createStore().then(
                    () => {
                        this._setDefaults();
                    },
                    (e) => {
                        console.log(e);
                        this.picker.setDefaultValue([]);
                    });
            }
        }

        this.callParent(arguments);
        if (this.sharedSchedules) {
            this._addPills(this.recordsToAdd);
        }
    },

    getValue() {
        const { picker } = this;
        if (picker) {
            return picker.getValue();
        }

        return [];
    },

    getFilter() {
        return this.picker && this.picker.getFilter();
    },

    getLookbackFilter() {
        return this.picker && this.picker.getLookbackFilter();
    },

    saveStateLocal(records) {
        if (this.statefulKey) {
            try {
                localStorage.setItem(this.statefulKey, JSON.stringify(_.invoke(records, 'get', '_ref')));
            } catch (e) {
                // noop
            }
        }
    },

    _onInitialDataChanged() {
        this._setDefaults();
    },

    _setDefaults() {
        if (this.recordsToAdd.length === 0) {
            if (this.defaultToRecentTimeboxes) {
                Ext.create('Rally.data.wsapi.Store', {
                    model: 'Release',
                    autoLoad: true,
                    limit: 4,
                    pageSize: 4,
                    remoteSort: true,
                    remoteFilter: true,
                    fetch: ['ObjectID', 'Name', 'ReleaseStartDate', 'ReleaseDate'],
                    sorters: [{ property: 'ReleaseDate', direction: 'DESC' }],
                    filters: [{ property: 'ReleaseStartDate', operator: '<', value: new Date() }],
                    context: {
                        project: Rally.getApp().getContext().getProjectRef(),
                        projectScopeUp: false,
                        projectScopeDown: false
                    },
                    listeners: {
                        scope: this,
                        load: function (store, data, success) {
                            if (success) {
                                this.picker.setDefaultValue(data);
                                this._addPills(data);
                            }
                            else {
                                this.picker.setDefaultValue([]);
                            }
                        }
                    }
                });
            } else {
                this.picker.setValueBasedOnState([]);
            }
        }
    },

    _onInitialExpand() {
        if (this.picker.getList()) {
            this.picker.getList().pagingToolbar.onLoad();
            this.picker.getList().refresh();
        }
    },

    _addPills(records) {
        let recordsForPills = records;
        if (!this.showPills) {
            return;
        }
        if (this.sharedSchedules) {
            let foundRecords = {};
            recordsForPills = _.filter(records, (record) => {
                let key = `${record.get('Name')}-${record.get(this.startDateFieldName)}-${record.get(this.endDateFieldName)}`;
                if (!foundRecords[key]) {
                    foundRecords[key] = true;
                    return true;
                }
                return false;
            });
        }

        const pills = _.map(recordsForPills, record => ({
            xtype: 'component',
            flex: 1,
            itemId: `pill-id-${record.getId()}`,
            renderTpl: '<span class="tagPill">{Name}<span class="icon-cancel"></span></span>',
            renderData: record.getData(),
            renderSelectors: {
                tagPill: '.tagPill',
                removePillEl: '.icon-cancel'
            },
            listeners: {
                click: {
                    element: 'tagPill',
                    fn: (e) => {
                        e.preventDefault();
                        this._onRemovePillClick(record);
                    },
                    scope: this
                }
            }
        }), this);
        const newPills = _.filter(pills, cmp => _.isEmpty(this.down(`#${cmp.itemId}`)), this);

        if (newPills.length > 0) {
            this.down('#pillContainer').add(newPills);
        }
    },

    _createItems() {
        return [
            this.picker,
            {
                itemId: 'pillContainer',
                xtype: 'container',
                cls: 'pill-select-container',
                margin: '10 0 0 0',
                layout: {
                    type: 'table',
                    columns: 3
                }
            }
        ];
    },

    _removePills() {
        _.each(this.down('#pillContainer').items.getRange(), (cmp) => {
            cmp.destroy();
        });
    },

    _removePill(record) {
        let pillEl = this.down(`#pill-id-${record.getId()}`);
        if (pillEl) {
            pillEl.destroy();
        }
    },

    _onSelectionChange(cmp, records) {
        Ext.suspendLayouts();
        this._removePills();
        this._addPills(records);
        Ext.resumeLayouts(true);
        this.saveStateLocal(records);
    },

    _onItemSelect(cmp, record) {
        this._addPills(Ext.Array.from(record));
    },

    _onItemDeselect(cmp, record) {
        this._removePill(record);
    },

    _findSharedSchedules(record) {
        const selectedValues = this.picker.selectedValues.getRange();
        const key = `${record.get('Name')}-${record.get(this.startDateFieldName)}-${record.get(this.endDateFieldName)}`;
        return _.filter(selectedValues, (timebox) => {
            const timeboxKey = `${timebox.get('Name')}-${timebox.get(this.startDateFieldName)}-${timebox.get(this.endDateFieldName)}`;
            return timeboxKey === key;
        });
    },

    _onRemovePillClick(record) {
        if (this.sharedSchedules) {
            const recordsToRemove = this._findSharedSchedules(record);
            _.each(recordsToRemove, (r) => {
                this.picker.onListItemDeselect(null, r);
                this._removePill(r);
            });
        } else {
            this.picker.onListItemDeselect(null, record);
            this._removePill(record);
        }

        this.saveStateLocal(this.picker.selectedValues.getRange());
        this.fireEvent('recordremoved', this.picker.selectedValues, record, this.picker);
    },

    _setPillsFromPrjRef(selectedItems) {
        return new Promise(resolve => {
            Ext.create('Rally.data.wsapi.RefsToRecords').convert(selectedItems, { requester: this }).then({
                success: (recordsToAdd) => {
                    this.recordsToAdd = recordsToAdd;
                    if (recordsToAdd && recordsToAdd.length > 0) {
                        this.picker.setValueBasedOnState(recordsToAdd);
                        this._addPills(recordsToAdd);
                        this.saveStateLocal(recordsToAdd);
                    } else {
                        this._setDefaults();
                    }
                    resolve();
                },
                failure: (e) => {
                    console.log(e);
                    resolve();
                },
                scope: this
            });
        });
    }

});
                Ext.define('Customagile.ui.ProjectPicker', {
    extend: 'Ext.Container',
    alias: 'widget.customagileprojectpicker',
    layout: 'vbox',

    cmp: null,
    appName: '',
    tab: null,

    initComponent() {
        this.callParent(arguments);

        this.add([
            // {
            //     xtype: 'component',
            //     html: `If you require a report spanning across multiple project hierarchies, use this project picker to specify where the data will be pulled from. If blank, app will respect user's current project scoping.`,
            //     itemId: 'pheader',
            //     cls: 'x-form-item-label'
            // },
            {
                xtype: 'customagilepillpicker',
                itemId: 'projectPicker',
                hidden: false,
                statefulKey: this.cmp.getContext().getScopedStateId(this.appName + '-project-picker'),
                defaultToRecentTimeboxes: false,
                listeners: {
                    recordremoved: this.showApplyProjectsBtn,
                    scope: this
                },
                pickerCfg: {
                    xtype: 'customagilemultiselectproject',
                    width: 350,
                    margin: '10 0 0 0',
                    listeners: {
                        stateapplied: () => this._onReady(),
                        defaultapplied: () => this._onReady(),
                        blur: this.showApplyProjectsBtn,
                        scope: this
                    }
                }
            },
            {
                xtype: 'rallycheckboxfield',
                itemId: 'includeChildProjectsCheckbox',
                fieldLabel: 'Show work from child projects',
                labelSeparator: '',
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId(this.appName + '-scope-down-checkbox'),
                stateEvents: ['change'],
                labelWidth: 200,
                listeners: {
                    scope: this,
                    change: this.showApplyProjectsBtn
                }
            },
            // {
            //     xtype: 'rallybutton',
            //     itemId: 'applyProjectsBtn',
            //     text: 'Apply',
            //     margin: '10 0 0 0',
            //     hidden: true,
            //     handler: function (btn) {
            //         btn.hide();
            //         this.fireEvent('applyprojects');
            //     }.bind(this)
            // }
        ]);

        this.projectPicker = this.down('#projectPicker');
    },

    _onReady() {
        setTimeout(() => this.updateProjectTabText(), 1000);
        setTimeout(() => this.fireEvent('ready'), 200);
    },

    showApplyProjectsBtn() {
        // if (this.down('#applyProjectsBtn')) { this.down('#applyProjectsBtn').show(); }
        // this.updateProjectTabText();
        // this.fireEvent('projectschanged');
    },

    updateProjectTabText() {
        if (this.tab) {
            if (this.cmp.down('#ignoreScopeControl') && this.cmp.down('#ignoreScopeControl').getValue() === 'workspace') {
                this.tab.setTitle('PROJECTS (ALL)');
            }
            else if (this.projectPicker && !this.projectPicker.hidden) {
                let totalProjects = this.projectPicker.getValue().length;
                let titleText = totalProjects ? `PROJECTS (${totalProjects})` : 'PROJECTS';
                this.tab.setTitle(titleText);
            }
            else {
                this.tab.setTitle('PROJECTS');
            }
        }
    },

    getValue() {
        return this.projectPicker.getValue();
    },

    includeChildProjects() {
        return this.down('#includeChildProjectsCheckbox').getValue();
    },

    setIncludeChildProjects(searchChildProjects) {
        this.down('#includeChildProjectsCheckbox').setValue(searchChildProjects);
    },

    reset() {
        this.projectPicker._removePills();
        this.projectPicker.picker.setValueBasedOnState([]);
        this.projectPicker.saveStateLocal([]);
        this.updateProjectTabText();
        this.down('#includeChildProjectsCheckbox').setValue(false);
        this.projectPicker.picker.setDefaultValue([]);
        // if (this.down('#applyProjectsBtn')) { this.down('#applyProjectsBtn').hide(); }
        //this.projectPicker.this._setDefaults();
    },

    getProjectRefs() {
        return _.map(this.projectPicker.getValue(), (p) => {
            return p.get('_ref');
        });
    },

    async setValueFromPrjRef(prjs, searchChildProjects) {
        this.setIncludeChildProjects(searchChildProjects);
        await this.projectPicker._setPillsFromPrjRef(prjs);
    },

    async updatePickerFromOldPicker(appName, childProjectCheck) {
        let prjs = JSON.parse(localStorage.getItem(this.cmp.getContext().getScopedStateId(appName + '-project-picker')));
        if (prjs && prjs.length > 0) {
            await this.setValueFromPrjRef(prjs, childProjectCheck);
        }
        localStorage.removeItem(this.cmp.getContext().getScopedStateId(appName + '-project-picker'));
    }

});
                Ext.define('CustomAgile.ui.popover.SummaryGridPopover', {
    alias: 'widget.summarygridpopover',
    extend: 'Rally.ui.popover.Popover',
    id: 'grid-popover',
    cls: 'grid-popover',
    title: 'Collection Details',
    width: 750,
    maxHeight: 600,
    layout: 'fit',

    constructor: function (config) {
        if (config.title) {
            this.title = config.title;
        }

        let items = [{
            xtype: 'rallygrid',
            itemId: 'listview',
            store: config.store,
            storeConfig: { fetch: config.fetch, sorters: config.sorters },
            columnCfgs: config.columns,
            sortableColumns: true,
            showRowActionsColumn: false,
            showPagingToolbar: true,
            enableEditing: false,
            flex: 1,
            overflowY: 'auto'
        }];

        config.items = Ext.merge(items, config.items);

        this.callParent(arguments);
    },

    getGrid: function () {
        return this.down('#listview');
    }
});
                Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    layout: { type: 'vbox', align: 'stretch' },
    items: [{
        id: 'dropdownFiltersContainer',
        xtype: 'container',
        margin: 10,
        layout: {
            type: 'hbox',
            defaultMargins: '0 30 0 0',
        }
    }, {
        id: 'mainContainer',
        xtype: 'container',
        flex: 1,
        layout: {
            type: 'vbox',
            align: 'stretch',
            defaultMargins: 5,
        }
    }],

    launch() {
        Rally.data.wsapi.Proxy.superclass.timeout = 120000;
        this.down('#mainContainer').on('resize', this.onGridResize);
        let context = this.getContext();

        Ext.override(Ext.form.field.Checkbox, {
            getState: function () {
                return { checked: this.getValue() };
            },
            applyState: function (state) {
                if (typeof state.checked === 'boolean') {
                    this.setValue(state.checked);
                }
            }
        });

        this.down('#dropdownFiltersContainer').add([{
            xtype: 'customagileprojectpicker',
            cmp: this,
            appName: 'milestones-by-target-project',
            listeners: {
                scope: this,
                ready: () => this._onProjectSelected(),
                // projectschanged: () => {
                //     this.refreshProjects = true;
                // },
                applyprojects: () => this._onProjectSelected()
            }
        }, {
            xtype: 'container',
            layout: 'vbox',
            items: [
                {
                    xtype: 'rallytextfield',
                    itemId: 'idFilter',
                    fieldLabel: 'ID',
                    labelSeparator: '',
                    stateful: true,
                    stateId: context.getScopedStateId('id-filter'),
                    stateEvents: ['change']
                },
                {
                    xtype: 'rallyfieldvaluecombobox',
                    itemId: 'milestoneTypeFilter',
                    model: 'Milestone',
                    field: 'c_Type',
                    fieldLabel: 'Type',
                    labelSeparator: '',
                    stateful: true,
                    stateId: context.getScopedStateId('milestone-type'),
                    stateEvents: ['change']
                },
                {
                    xtype: 'rallyfieldvaluecombobox',
                    itemId: 'milestoneActiveFilter',
                    model: 'Milestone',
                    field: 'c_Active',
                    fieldLabel: 'Active',
                    labelSeparator: '',
                    allowBlank: true,
                    allowNoEntry: true,
                    stateful: true,
                    stateId: context.getScopedStateId('milestone-active'),
                    stateEvents: ['change']
                }
            ]
        }, {
            xtype: 'container',
            layout: 'vbox',
            items: [
                {
                    xtype: 'checkboxfield',
                    itemId: 'archivedProjectsFilter',
                    fieldLabel: 'Has archived projects',
                    width: 200,
                    labelWidth: 175,
                    labelSeparator: '',
                    // listeners: {
                    //     change: this._onProjectSelected,
                    //     scope: this
                    // },
                    stateful: true,
                    stateId: context.getScopedStateId('has-archived-projects'),
                    stateEvents: ['change']
                }, {
                    xtype: 'checkboxfield',
                    itemId: 'archivedArtifactsFilter',
                    fieldLabel: 'Has archived Artifacts',
                    width: 200,
                    labelWidth: 175,
                    labelSeparator: '',
                    // listeners: {
                    //     change: this._onProjectSelected,
                    //     scope: this
                    // },
                    stateful: true,
                    stateId: context.getScopedStateId('has-archived-artifacts'),
                    stateEvents: ['change']
                }
            ]
        }, {
            xtype: 'container',
            layout: 'vbox',
            items: [
                {
                    xtype: 'rallybutton',
                    itemId: 'applySettingsBtn',
                    text: 'Apply Settings',
                    handler: () => this._onProjectSelected()
                }
            ]
        }]);

        this.projectPicker = this.down('customagileprojectpicker');
    },

    async addGrid() {
        let context = this.getContext();
        let dataContext = context.getDataContext();
        this.setLoading(true);

        try {
            this.down('#mainContainer').add(
                {
                    xtype: 'rallygrid',
                    editable: false,
                    storeConfig: {
                        filters: await this.getFilters(),
                        model: 'milestone',
                        context: dataContext,
                        enablePostGet: true
                    },
                    // stateful: true,
                    // stateId: context.getScopedStateId('milestones-grid'),
                    height: this.down('#mainContainer').getHeight(),
                    columnCfgs: [
                        'FormattedID',
                        'Name',
                        {
                            dataIndex: 'Projects',
                            text: 'All Projects',
                            flex: 1,
                            renderer: function (value, metaData, record) {
                                return `<a onclick="Rally.getApp().showCollectionGrid(event,${record.get('ObjectID')}, 'Projects'); return false;">
                                        <span class="grid-link">${value.Count}</span>
                                    </a>`;
                            }
                        },
                        {
                            dataIndex: 'Artifacts',
                            text: 'All Artifacts',
                            flex: 1,
                            renderer: function (value, metaData, record) {
                                return `<a onclick="Rally.getApp().showCollectionGrid(event,${record.get('ObjectID')}, 'Artifacts'); return false;">
                                        <span class="grid-link">${value.Count}</span>
                                    </a>`;
                            }
                        },
                        'TargetDate',
                        'c_Type',
                        'c_Active'
                    ],
                });
        }
        catch (e) {
            this.showError(e);
        }
        this.setLoading(false);
    },

    _onProjectSelected() {
        this.down('#mainContainer').removeAll();
        this.addGrid();
    },

    showCollectionGrid(event, id, collectionName) {
        this.setLoading(`Loading ${collectionName}`);

        try {
            let record = this.down('rallygrid').store.getById(id);

            if (record) {
                let fetch = [];
                let columns = [];
                let sorters = [];

                if (collectionName === 'Projects') {
                    fetch = ['Name', 'Owner', 'Archived'];
                    columns = ['Name', 'Owner', 'Archived'];
                    sorters = ['Name'];
                }
                else if (collectionName === 'Artifacts') {
                    fetch = ['FormattedID', 'Name', 'Project'];
                    columns = ['FormattedID', 'Name', 'Project'];
                    sorters = ['FormattedID'];
                }

                let store = record.getCollection(collectionName);

                Ext.create(CustomAgile.ui.popover.SummaryGridPopover, {
                    title: collectionName,
                    target: event.target,
                    placement: ['bottom', 'top'],
                    offsetFromTarget: [
                        { x: 0, y: -5 },
                        { x: 5, y: 0 },
                        { x: 0, y: 5 },
                        { x: -5, y: 0 }
                    ],
                    models: ['Project'],
                    store,
                    fetch,
                    sorters,
                    maxWidth: this.down('rallygrid').getWidth(),
                    columns
                });

                this.setLoading(false);

                return false;
            }
        }
        catch (e) {
            this.showError(e);
        }
    },

    async getFilters() {
        let filters = [];
        let projects = await this.getProjects();

        if (projects.length) {
            filters.push({
                property: 'Projects',
                operator: projects.length > 1 ? 'in' : '=',
                value: projects.length > 1 ? projects : projects[0]
            });
        }

        if (this.down('#idFilter').getValue()) {
            filters.push({
                property: 'FormattedID',
                operator: 'contains',
                value: this.down('#idFilter').getValue()
            });
        }

        if (this.down('#milestoneTypeFilter').getValue()) {
            filters.push({
                property: 'c_Type',
                value: this.down('#milestoneTypeFilter').getValue()
            });
        }

        if (this.down('#milestoneActiveFilter').getValue()) {
            filters.push({
                property: 'c_Active',
                value: this.down('#milestoneActiveFilter').getValue()
            });
        }

        if (this.down('#archivedProjectsFilter').getValue()) {
            filters.push({
                property: 'Projects.c_Archived',
                value: 'Yes'
            });
        }

        if (this.down('#archivedArtifactsFilter').getValue()) {
            filters.push({
                property: 'Artifacts.Project.c_Archived',
                value: 'Yes'
            });
        }

        return filters;
    },

    async getProjects() {
        let projects = this.projectPicker.getValue() || [];

        if (this.projectPicker.includeChildProjects()) {
            projects = await this.getAllChildProjects(projects);
        }

        return _.map(projects, p => p.get('_ref'));
    },

    async getAllChildProjects(allRoots = [], fetch = ['Name', 'Children', 'ObjectID']) {
        if (!allRoots.length) { return []; }

        const promises = allRoots.map(r => this.wrap(r.getCollection('Children', { fetch, limit: Infinity, filters: [{ property: 'State', value: 'Open' }] }).load()));
        const children = _.flatten(await Promise.all(promises));
        const decendents = await this.getAllChildProjects(children, fetch);
        const removeDupes = {};
        let finalResponse = _.flatten([...decendents, ...allRoots, ...children]);

        // eslint-disable-next-line no-return-assign
        finalResponse.forEach(s => removeDupes[s.get('_ref')] = s);
        finalResponse = Object.values(removeDupes);
        return finalResponse;
    },

    onGridResize() {
        let grid = this.down('rallygrid');

        if (grid) {
            grid.setHeight(this.getHeight());
        }
    },

    setLoading(msg) {
        this.down('#mainContainer').setLoading(msg);
    },

    showError(msg) {
        this.setLoading(false);
        Rally.ui.notify.Notifier.showError({ message: this.parseError(msg) });
    },

    parseError(e, defaultMessage) {
        if (typeof e === 'string' && e.length) {
            return e;
        }
        if (e.message && e.message.length) {
            return e.message;
        }
        if (e.exception && e.error && e.error.errors && e.error.errors.length) {
            if (e.error.errors[0].length) {
                return e.error.errors[0];
            } else {
                if (e.error && e.error.response && e.error.response.status) {
                    return `${defaultMessage} (Status ${e.error.response.status})`;
                }
            }
        }
        if (e.exceptions && e.exceptions.length && e.exceptions[0].error) {
            return e.exceptions[0].error.statusText;
        }
        return defaultMessage;
    },

    async wrap(deferred) {
        if (!deferred || !_.isFunction(deferred.then)) {
            return Promise.reject(new Error('Wrap cannot process this type of data into a ECMA promise'));
        }
        return new Promise((resolve, reject) => {
            deferred.then({
                success(...args) {
                    resolve(...args);
                },
                failure(error) {
                    Rally.getApp().setLoading(false);
                    reject(error);
                }
            });
        });
    }
});


            Rally.launchApp('CustomApp', {
                name:"Milestones by Project",
                parentRepos:"",
                version:"0.1.1"
            });

        });
    </script>



    <style type="text/css">
        .grid-link {
  color: #337ec6;
  cursor: pointer;
}
.x-form-item-label {
  font-family: "Open Sans", -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol" !important;
  color: #58606e !important;
  font-size: 14px !important;
}

    </style>
</head>
<body>
</body>
</html>
